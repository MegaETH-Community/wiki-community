---
icon: linode
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Node Specialization

As discussed in the[ **Consensus & Execution**](../introduction/just-another-l2/consensus-and-execution.md) page, traditional **Layer-1 (L1) blockchains** often require every node to perform **all** the heavy lifting—consensus, transaction ordering, and execution—leading to redundant work and inherent scaling limits. **Node specialization** breaks this monolithic model by assigning **specific tasks** to **dedicated nodes**, unlocking significant gains in throughput and responsiveness.

### Diagram of Node Roles and Interactions

Below is a high-level diagram illustrating how MegaETH implements node specialization. You’ll see the four major node roles—**Sequencer**, **Prover**, **Replica**, and **Full Node**—as well as the interactions among them and an external **EigenDA** component for data availability.

<figure><img src="../.gitbook/assets/MegaETH_node_spe_v4 (2).png" alt=""><figcaption></figcaption></figure>

### How the Diagram Works

1. **Sequencer Node (Leader)**
   * **Role:**
     * Orders and executes transactions in real time.
     * Acts as the central processor, managing transaction sequencing and state updates.
   * **Interaction:**
     * **To Replica Nodes:** Sends _state diffs_ (state changes) via the p2p network.
     * **To Full Nodes:** Sends complete blocks for re-execution and validation.
     * **To Provers:** Sends _blocks and witnesses_ to facilitate proof generation.
     * **To EigenDA:** Publishes _blocks, witnesses, and state diffs_ for long-term availability.
   * **Key Advantage:**\
     Combines transaction ordering and execution into a single, high-performance node, eliminating consensus overhead and enabling real-time processing.
2. **Replica Nodes**
   * **Role:**
     * Receive _state diffs_ from the Sequencer and directly apply them to maintain an up-to-date local state.
     * Do not re-execute transactions but rely on prover-generated proofs for block validation.
   * **Interaction:**
     * **From Sequencer:** Receive state diffs through the p2p network.
     * **Verification:** Validate blocks indirectly using proofs generated by Provers.
   * **Key Advantage:**\
     This lightweight design dramatically lowers hardware requirements, making it cost-effective for users.
3. **Full Nodes**
   * **Role:**
     * Re-execute every transaction in the received blocks to validate their correctness and maintain a trustless, fully verified state.
     * Ensure network integrity for power users like bridge operators and market makers who require fast finality.
   * **Interaction:**
     * **From Sequencer:** Receive complete blocks for re-execution and validation.
   * **Key Advantage:**\
     While hardware costs are higher than Replica Nodes, Full Nodes benefit from auxiliary information to **optimize transaction re-execution**. Their functionality ensures trustlessness across the network.
4. **Prover Nodes**
   * **Role:**
     * Generate cryptographic proofs that attest to the correctness of state transitions asynchronously and out-of-order.
     * Facilitate indirect block validation for Replica Nodes.
   * **Interaction:**
     * **From Sequencer:** Receive _blocks and witnesses_ to generate proofs.
     * **To Replica Nodes:** Provide proofs that ensure block validity.
   * **Key Advantage:**\
     Provers isolate computationally intensive tasks, ensuring the broader network remains lightweight. Depending on the proof mechanism (e.g., ZK, Optimistic), their hardware requirements range from minimal to highly specialized (e.g., GPUs, FPGAs).
5.  **EigenDA**

    * **What It Is:**
      * An external data availability solution built on EigenLayer.
    * **Interaction:**
      * **From Sequencer:** Receives _blocks, witnesses, and state diffs_ for decentralized storage.
      * **To Nodes:** Provides the network with access to required data for validation and re-execution.

    For more details, refer to the [EigenLayer page](eigenlayer.md).

***

### Why Node Specialization Matters

1. **Efficiency Gains:** Eliminates redundant work across nodes, focusing computation where it’s most needed.
2. **Optimized Hardware and Software:** Critical tasks are concentrated in specialized nodes, enabling them to be tuned for maximum throughput.
3. **User-Friendly Options:** Low-barrier replica nodes coexist with high-performance sequencers, ensuring decentralization.
4. **Liveness and Security**
   * Robust: If the sequencer fails, the network can swiftly elect a new one.
   * Trustless: Provers ensure block validity, and full nodes independently verify state, preserving security guarantees.

### Hardware Requirements

<table><thead><tr><th width="127">Node Type</th><th>CPU</th><th>Memory</th><th>Network</th><th>Storage</th><th>Example VM Cost ($/h)</th></tr></thead><tbody><tr><td>Sequencer</td><td>100 cores</td><td>1-4 TB</td><td>10 Gbps</td><td>SSD</td><td>$10 (AWS r6a.48xlarge)</td></tr><tr><td>Prover (OP)</td><td>1 core</td><td>0.5 GB</td><td>Slow</td><td>None</td><td>$0.004 (AWS t4g.nano)</td></tr><tr><td>Replica Node</td><td>4-8 cores</td><td>16 GB</td><td>100 Mbps</td><td>SSD</td><td>$0.4 (AWS Im4gn.xlarge)</td></tr><tr><td>Full Node</td><td>16 cores</td><td>64 GB</td><td>200 Mbps</td><td>SSD</td><td>$1.6 (AWS Im4gn.4xlarge)</td></tr></tbody></table>

***

### Conclusion

MegaETH pushes node specialization further than traditional L2s by ensuring only **full nodes** re-execute transactions, while other nodes focus on lightweight, optimized tasks. This eliminates redundancy, maximizes performance, and maintains decentralization, setting a new benchmark for blockchain scalability.

Specialized nodes are the foundation of MegaETH’s efficiency. Next, discover how **Hyper-Optimizing the EVM** unleashes their full potential.
